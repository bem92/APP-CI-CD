name: Frontend CI/CD

on:
  # Déclenché automatiquement UNIQUEMENT si des fichiers frontend changent
  push:
    branches:
      - main
      - dev
    paths:
      - "front/**"
  pull_request:
    branches:
      - main
      - dev
    paths:
      - "front/**"
  
  # Permet de déclencher manuellement le workflow depuis l'interface GitHub
  workflow_dispatch:
    inputs:
      skip-docker:
        description: "Sauter la construction Docker"
        required: false
        type: boolean
        default: false
      skip-sonar:
        description: "Sauter l'analyse SonarCloud"
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: read

env:
  SONAR_HOST_URL: https://sonarcloud.io
  SONAR_ORG: bem92
  SONAR_FRONTEND_PROJECT_KEY: ${{ vars.SONAR_FRONTEND_PROJECT_KEY || 'front-app' }}

jobs:
  # Tests unitaires du frontend avec génération de la couverture de code
  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: front
    outputs:
      lcov-path: ${{ steps.cov.outputs.lcov }}
    steps:
      - name: Récupération du code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Installation de Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Installation de Chrome pour les tests
        uses: browser-actions/setup-chrome@v1

      - name: Installation des dépendances npm
        run: npm ci

      - name: Lancement des tests Angular
        env:
          CI: 'true'
          NG_CLI_ANALYTICS: 'false'
        run: |
          if npm test -- --watch=false --code-coverage --browsers=ChromeHeadless; then
            echo "Tests Angular OK"
          else
            echo "Fallback sur npm test classique"
            npm test -- --watch=false --code-coverage
          fi

      # Localisation du fichier de couverture LCOV pour SonarCloud
      - name: Recherche du rapport de couverture
        id: cov
        run: |
          if [ -d coverage ]; then
            lcov=$(find coverage -type f -name "lcov.info" | head -n 1 || true)
          else
            lcov=""
          fi
          echo "lcov=${lcov}" >> "$GITHUB_OUTPUT"

      - name: Sauvegarde des résultats de tests
        uses: actions/upload-artifact@v4
        with:
          name: frontend-artifacts
          if-no-files-found: ignore
          path: front/coverage/**

  # Analyse de la qualité du code frontend sur SonarCloud
  # S'exécute uniquement si les tests sont passés et que ce n'est pas un fork
  frontend-sonar:
    name: Frontend SonarCloud
    runs-on: ubuntu-latest
    needs: frontend-tests
    if: >-
      ${{ needs.frontend-tests.result == 'success' && 
          (github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false) &&
          (github.event_name != 'workflow_dispatch' || inputs.skip-sonar != true) }}
    steps:
      - name: Récupération du code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # On récupère les artifacts du job précédent (coverage)
      - name: Récupération des artifacts de tests
        if: ${{ needs.frontend-tests.outputs['lcov-path'] != '' }}
        uses: actions/download-artifact@v4
        with:
          name: frontend-artifacts
          path: .

      - name: Vérification du rapport de couverture
        working-directory: front
        run: |
          lcov_path="${{ needs.frontend-tests.outputs['lcov-path'] }}"

          if [ -z "${lcov_path}" ]; then
            echo "Aucun rapport de couverture n'a été trouvé lors des tests" >&2
            exit 1
          fi
          if [ ! -f "${lcov_path}" ]; then
            alt_path="../${lcov_path}"
            if [ -f "${alt_path}" ]; then
              mkdir -p "$(dirname "${lcov_path}")"
              mv "${alt_path}" "${lcov_path}"
            fi
          fi

          if [ ! -f "${lcov_path}" ]; then
            found_path=$(find .. -type f -name "$(basename "${lcov_path}")" | head -n 1 || true)
            if [ -n "${found_path}" ] && [ -f "${found_path}" ]; then
              mkdir -p "$(dirname "${lcov_path}")"
              cp "${found_path}" "${lcov_path}"
            fi
          fi

          if [ ! -f "${lcov_path}" ]; then
            echo "Fichier de couverture introuvable: ${lcov_path}" >&2
            exit 1
          fi

      # Configuration pour les Pull Requests
      - name: Configuration des paramètres PR
        id: sonar-context
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "args=-Dsonar.pullrequest.key=${{ github.event.pull_request.number }} -Dsonar.pullrequest.branch=${{ github.head_ref }} -Dsonar.pullrequest.base=${{ github.base_ref }}" >> "$GITHUB_OUTPUT"
          else
            echo "args=" >> "$GITHUB_OUTPUT"
          fi

      - name: Analyse SonarCloud
        uses: SonarSource/sonarcloud-github-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_FRONT }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.organization=${{ env.SONAR_ORG }}
            -Dsonar.projectKey=${{ env.SONAR_FRONTEND_PROJECT_KEY }}
            -Dsonar.projectBaseDir=front
            -Dsonar.sources=src
            -Dsonar.tests=src
            -Dsonar.test.inclusions=**/*.spec.ts,**/*.test.ts
            ${{ needs.frontend-tests.outputs['lcov-path'] && format('-Dsonar.javascript.lcov.reportPaths={0}', needs.frontend-tests.outputs['lcov-path']) || '' }}
            ${{ needs.frontend-tests.outputs['lcov-path'] && format('-Dsonar.typescript.lcov.reportPaths={0}', needs.frontend-tests.outputs['lcov-path']) || '' }}
            ${{ steps.sonar-context.outputs.args }}

      - name: Vérification du Quality Gate
        uses: SonarSource/sonarqube-quality-gate-action@v1.2.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_FRONT }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          scanMetadataReportFile: front/.scannerwork/report-task.txt
          pollingTimeoutSec: 600

  # Build et publication de l'image Docker du frontend sur Docker Hub
  # Ne s'exécute que sur les branches main et dev après validation des tests et de SonarCloud
  docker-frontend:
    name: Docker Frontend
    runs-on: ubuntu-latest
    needs:
      - frontend-tests
      - frontend-sonar
    if: >-
      ${{ always() &&
          needs.frontend-tests.result == 'success' &&
          (needs.frontend-sonar.result == 'success' || needs.frontend-sonar.result == 'skipped') &&
          (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
          (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev') &&
          (github.event_name != 'workflow_dispatch' || inputs.skip-docker != true) }}
    steps:
      - name: Récupération du code
        uses: actions/checkout@v4

      - name: Configuration de Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Connexion à Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Génération automatique des tags: front-latest pour main, front-dev pour dev
      - name: Génération des tags Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: docker.io/nejrima/projet10
          flavor: |
            prefix=front-
            latest=false
          tags: |
            type=raw,value=latest,enable=${{ github.ref_name == 'main' }}
            type=raw,value=dev,enable=${{ github.ref_name == 'dev' }}

      - name: Build et push de l'image Docker
        uses: docker/build-push-action@v6
        with:
          context: front
          file: front/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max